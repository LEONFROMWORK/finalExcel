# frozen_string_literal: true

namespace :embeddings do
  desc "Check existing QA pairs for fake embeddings"
  task check_fake: :environment do
    puts "Checking for QA pairs with fake embeddings..."
    
    total_qa_pairs = KnowledgeBase::QaPair.count
    qa_with_embeddings = KnowledgeBase::QaPair.where.not(embedding: nil).count
    qa_without_embeddings = KnowledgeBase::QaPair.where(embedding: nil).count
    
    puts "\nTotal QA pairs: #{total_qa_pairs}"
    puts "QA pairs with embeddings: #{qa_with_embeddings}"
    puts "QA pairs without embeddings: #{qa_without_embeddings}"
    
    # Check for fake embeddings (generated by AiEmbeddingService)
    # Fake embeddings have specific patterns - they always start with hash-based values
    fake_count = 0
    real_count = 0
    
    KnowledgeBase::QaPair.where.not(embedding: nil).find_each do |qa|
      if qa.embedding.present? && qa.embedding.is_a?(Array)
        # Check if it's likely a fake embedding
        # Fake embeddings from AiEmbeddingService have very specific patterns
        first_values = qa.embedding[0..4]
        if first_values.all? { |v| v.abs < 0.1 } # Fake embeddings tend to have small initial values
          fake_count += 1
        else
          real_count += 1
        end
      end
    end
    
    puts "\nEmbedding analysis:"
    puts "Likely fake embeddings: #{fake_count}"
    puts "Likely real embeddings: #{real_count}"
    
    # Show sample QA pairs
    if total_qa_pairs > 0
      puts "\nSample QA pairs:"
      KnowledgeBase::QaPair.limit(5).each do |qa|
        puts "\nID: #{qa.id}"
        puts "Question: #{qa.question[0..100]}..."
        puts "Has embedding: #{qa.embedding.present?}"
        puts "Embedding size: #{qa.embedding&.size || 0}"
        puts "Source: #{qa.source}"
      end
    end
  end

  desc "Regenerate embeddings for QA pairs with tracking"
  task regenerate: :environment do
    puts "Starting embedding regeneration..."
    
    # First, ensure we have OpenAI API key
    if ENV['OPENAI_API_KEY'].blank? || ENV['OPENAI_API_KEY'] == 'your_openai_api_key_here'
      puts "ERROR: OpenAI API key not configured!"
      exit 1
    end
    
    qa_pairs_to_update = KnowledgeBase::QaPair.where(embedding: nil).or(KnowledgeBase::QaPair.where(embedding: []))
    total = qa_pairs_to_update.count
    
    puts "Found #{total} QA pairs needing embeddings"
    
    if total == 0
      # Check all embeddings to regenerate fake ones
      puts "Checking all embeddings for fake ones..."
      qa_pairs_to_update = KnowledgeBase::QaPair.all
      total = qa_pairs_to_update.count
    end
    
    # Create VectorDbStatus record for tracking
    batch_id = "embedding_batch_#{Time.current.to_i}"
    status = VectorDbStatus.start_conversion(
      source_type: 'ManualUpload',
      source_id: batch_id,
      total_items: total,
      metadata: {
        task: 'regenerate_embeddings',
        started_by: 'rake_task'
      }
    )
    
    puts "Tracking progress with batch ID: #{batch_id}"
    
    processed = 0
    errors = 0
    
    qa_pairs_to_update.find_each.with_index do |qa, index|
      begin
        # Trigger embedding generation with tracking
        GenerateEmbeddingJob.perform_now(
          'KnowledgeBase::QaPair', 
          qa.id,
          'ManualUpload',
          batch_id
        )
        processed += 1
        
        if (index + 1) % 10 == 0
          puts "Progress: #{index + 1}/#{total} (#{((index + 1) * 100.0 / total).round(2)}%)"
        end
      rescue => e
        errors += 1
        puts "Error processing QA pair #{qa.id}: #{e.message}"
      end
      
      # Rate limiting to avoid API limits
      sleep 0.1
    end
    
    puts "\nRegeneration complete!"
    puts "Processed: #{processed}"
    puts "Errors: #{errors}"
    
    # Display final status
    status.reload
    puts "\nFinal Status:"
    puts "Total items: #{status.total_items}"
    puts "Processed: #{status.processed_items}"
    puts "Failed: #{status.failed_items}"
    puts "Embeddings created: #{status.embeddings_created}"
    puts "Success rate: #{status.success_rate}%"
    puts "Duration: #{status.duration_in_minutes} minutes"
  end
end